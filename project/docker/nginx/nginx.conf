# Nginx Configuration File
#
# WHAT THIS DOES:
# This configuration file tells Nginx how to route incoming HTTP requests to different
# microservices. It acts as a reverse proxy, forwarding requests to the appropriate
# backend service based on the URL path.
#
# KEY CONCEPTS:
# - upstream: Defines a group of backend servers (our microservices)
# - location: Matches URL paths and routes them to upstream servers
# - proxy_pass: Forwards the request to the specified upstream server

# Main configuration block
events {
    # Maximum number of simultaneous connections
    worker_connections 1024;
}

http {
    # Include MIME types (tells Nginx how to handle different file types)
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # Logging configuration
    # access_log: Records all incoming requests
    # error_log: Records errors and warnings
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    # Performance optimizations
    sendfile on;  # Efficient file transfer
    tcp_nopush on;  # Optimize TCP packets
    keepalive_timeout 65;  # Keep connections alive for 65 seconds

    # Define upstream servers for each microservice
    # These are the backend services that Nginx will forward requests to
    # In Kubernetes, these will be service names (e.g., user-service.default.svc.cluster.local)
    
    # User service - handles user-related operations (create, read, update user profiles)
    upstream user-service {
        # In Kubernetes, this will resolve to the service endpoint
        # The service will load balance across all available pods
        server user-service:8080;
    }

    # Social graph service - manages friend connections and social relationships
    upstream social-graph-service {
        server social-graph-service:9090;
    }

    # User timeline service - manages user activity timelines
    upstream user-timeline-service {
        server user-timeline-service:9091;
    }

    # Main server block - handles all incoming HTTP requests
    server {
        # Listen on port 80 (standard HTTP port)
        listen 80;
        
        # Server name (can be a domain name or IP address)
        server_name localhost;

        # Route requests to user service
        # This matches URLs starting with /user/
        location /user/ {
            # Forward the request to the user-service upstream
            proxy_pass http://user-service/;
            
            # Preserve the original host header (important for some applications)
            proxy_set_header Host $host;
            
            # Forward the client's IP address to the backend
            proxy_set_header X-Real-IP $remote_addr;
            
            # Forward proxy information
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Route requests to social graph service
        location /social-graph/ {
            proxy_pass http://social-graph-service/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Route requests to user timeline service
        location /user-timeline/ {
            proxy_pass http://user-timeline-service/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Health check endpoint
        # Kubernetes uses this to check if the pod is healthy
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }
}

